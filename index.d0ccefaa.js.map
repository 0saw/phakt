{"mappings":"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","sources":["src/utils/game.ts","src/utils/index.ts","src/index.ts"],"sourcesContent":["/**\n * Ограничивает значение сверху и снизу\n */\nexport const clamp = (n: number, min: number, max: number): number => Math.min(max, Math.max(min, n))\n\n/**\n * Передвигает элемент при этом учитывает границы экрана и возможный offset, заданный на элементе\n */\nexport const move = (element: HTMLElement, x: number, y: number): void => {\n  const offsetX = parseFloat(element.dataset.offsetX ?? '0')\n  const offsetY = parseFloat(element.dataset.offsetY ?? '0')\n\n  element.style.transform = `translate(\n    ${clamp(x - offsetX, 0, window.innerWidth - element.clientWidth) - window.innerWidth / 2}px, \n    ${clamp(y - offsetY, 0, window.innerHeight - element.clientHeight) - window.innerHeight / 2}px\n  )`\n}\n\n/**\n * Получает кусочек пазла\n */\nexport const getPiece = (\n  src: string,\n  width: number,\n  height: number,\n  tilesCountX: number,\n  tilesCountY: number,\n  tileX: number,\n  tileY: number\n): HTMLDivElement => {\n  const piece = document.createElement('div')\n\n  piece.dataset.piece = 'true'\n  piece.hidden = true\n  piece.style.cssText = `\n    position: absolute;\n    top: 50vh;\n    left: 50vw;\n    width: ${width}px;\n    height: ${height}px;\n    background-image: url(${src});\n    background-position: ${-width * tileX}px ${-height * tileY}px;\n    background-size: ${tilesCountX * 100}% ${tilesCountY * 100}%;\n    transform: translate(0, 0);\n    user-select: none;\n  `\n\n  return piece\n}\n\nlet didWin = false\nexport const checkWin = (scene: HTMLElement[]): void => {\n  if (!didWin && scene.every((element) => element.dataset.correct === 'true')) {\n    didWin = true\n    alert('Pobeda')\n  }\n}\n","export * from './game'\n\n/**\n * Возвращает растояние между двумя точками\n */\nexport const getDistance = (x1: number, y1: number, x2: number, y2: number): number => (\n  ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n)\n\n/**\n * Проверяет, попадает ли точка в элемент\n */\nexport const isIntersecting = (element: Element, x: number, y: number): boolean => {\n  const elementRect = element.getBoundingClientRect()\n\n  return x >= elementRect.left && x <= elementRect.right && y >= elementRect.top && y <= elementRect.bottom\n}\n","import { getPiece, getDistance, isIntersecting, move, checkWin } from './utils'\n\nconst PIECE_COUNT_X = 3\nconst PIECE_COUNT_Y = 2\nconst PIECE_WIDTH = 120\nconst PIECE_HEIGHT = 100\nconst IMAGE = `${process.env.RANDOM_IMAGE_SERVICE}/${PIECE_WIDTH * PIECE_COUNT_X}/${PIECE_HEIGHT * PIECE_COUNT_Y}`\n\nconst game = document.querySelector<HTMLDivElement>('.game')\nconst gameArea = document.querySelector<HTMLDivElement>('.game__area')\nconst bag = document.querySelector<HTMLDivElement>('.game__bag')\n\n// Хранит значение z-index последнего передвинутого элемента\nlet zIndex = 1\n\nif (game === null || gameArea === null || bag === null) {\n  throw Error('No game area found')\n}\n\ngameArea.style.width = `${PIECE_WIDTH * PIECE_COUNT_X}px`\ngameArea.style.height = `${PIECE_HEIGHT * PIECE_COUNT_Y}px`\n\nconst scene = new Array<HTMLDivElement>()\n\nfor (let y = 0; y < PIECE_COUNT_Y; y++) {\n  for (let x = 0; x < PIECE_COUNT_X; x++) {\n    const piece = getPiece(IMAGE, PIECE_WIDTH, PIECE_HEIGHT, PIECE_COUNT_X, PIECE_COUNT_Y, x, y)\n\n    scene.push(piece)\n    game.append(piece)\n  }\n}\n\nconst onPointerMove = (e: PointerEvent): void => {\n  bag.classList.toggle('game__bag--active', isIntersecting(bag, e.x, e.y))\n\n  if (!(e.target instanceof HTMLDivElement && 'piece' in e.target.dataset)) {\n    return\n  }\n\n  move(e.target, e.x, e.y)\n}\n\nconst onPointerUp = (e: PointerEvent): void => {\n  game.removeEventListener('pointermove', onPointerMove)\n  game.removeEventListener('pointerup', onPointerUp)\n\n  bag.classList.remove('game__bag--active')\n\n  if (!(e.target instanceof HTMLDivElement && 'piece' in e.target.dataset)) {\n    return\n  }\n\n  const piece = e.target\n  piece.dataset.offsetX = '0'\n  piece.dataset.offsetY = '0'\n\n  if (isIntersecting(bag, e.x, e.y)) {\n    piece.hidden = true\n  }\n\n  const gameAreaRect = gameArea.getBoundingClientRect()\n  const pieceRect = piece.getBoundingClientRect()\n  const pieceCenterRelativeToGameAreaX = pieceRect.left - gameAreaRect.left + pieceRect.width / 2\n  const pieceCenterRelativeToGameAreaY = pieceRect.top - gameAreaRect.top + pieceRect.height / 2\n  const totalTilesX = Math.round(gameAreaRect.width / pieceRect.width)\n  const totalTilesY = Math.round(gameAreaRect.height / pieceRect.height)\n  const tileX = Math.floor(pieceCenterRelativeToGameAreaX / gameAreaRect.width * totalTilesX)\n  const tileY = Math.floor(pieceCenterRelativeToGameAreaY / gameAreaRect.height * totalTilesY)\n\n  if (\n    tileX >= 0 && tileX < totalTilesX && tileY >= 0 && tileY < totalTilesY &&\n    getDistance(\n      tileX * pieceRect.width + pieceRect.width / 2, tileY * pieceRect.height + pieceRect.height / 2,\n      pieceCenterRelativeToGameAreaX, pieceCenterRelativeToGameAreaY\n    ) < 0.15 * getDistance(\n      pieceRect.left, pieceRect.top,\n      pieceRect.right, pieceRect.bottom\n    )\n  ) {\n    piece.dataset.correct = scene[tileY * totalTilesX + tileX] === piece ? 'true' : 'false'\n\n    move(piece, gameAreaRect.left + tileX * pieceRect.width, gameAreaRect.top + tileY * pieceRect.height)\n    checkWin(scene)\n  } else {\n    piece.dataset.correct = 'false'\n  }\n}\n\nconst onPointerDown = (e: PointerEvent): void => {\n  let piece: HTMLDivElement | undefined\n  let offsetX = e.offsetX\n  let offsetY = e.offsetY\n\n  if (e.target instanceof HTMLDivElement && 'piece' in e.target.dataset) {\n    piece = e.target\n  } else if (isIntersecting(bag, e.x, e.y)) {\n    const availablePieces = scene\n      .filter((element) => element.hidden)\n      .sort(() => Math.random() - 0.5)\n    const nextPiece = availablePieces.pop()\n\n    if (typeof nextPiece !== 'undefined') {\n      piece = nextPiece\n      offsetX = nextPiece.clientWidth / 2\n      offsetY = nextPiece.clientHeight / 2\n    }\n  }\n\n  if (typeof piece === 'undefined') {\n    return\n  }\n\n  piece.hidden = false\n  piece.dataset.offsetX = `${offsetX}`\n  piece.dataset.offsetY = `${offsetY}`\n  piece.style.zIndex = `${zIndex++}`\n  piece.setPointerCapture(e.pointerId)\n  move(piece, e.x, e.y)\n\n  game.addEventListener('pointermove', onPointerMove)\n  game.addEventListener('pointerup', onPointerUp)\n}\n\ngame.addEventListener('pointerdown', onPointerDown)\n"],"names":["$cf0dc7738f3ed19c$export$7d15b64cf5a3a4c4","n","min","max","Math","$cf0dc7738f3ed19c$export$d947e5f4f4c48d48","element","x","y","offsetX","parseFloat","dataset","offsetY","style","transform","window","innerWidth","clientWidth","innerHeight","clientHeight","$cf0dc7738f3ed19c$export$191e7bd1dd3304e7","src","width","height","tilesCountX","tilesCountY","tileX","tileY","piece","document","createElement","hidden","cssText","$cf0dc7738f3ed19c$var$didWin","$34d8ee2ebd983fd3$export$79376507b09a66f","x1","y1","x2","y2","$34d8ee2ebd983fd3$export$8d3dd0be5eb9f11f","elementRect","getBoundingClientRect","left","right","top","bottom","$559c39b934b932c4$var$game","querySelector","$559c39b934b932c4$var$gameArea","$559c39b934b932c4$var$bag","$559c39b934b932c4$var$zIndex","Error","$559c39b934b932c4$var$scene","Array","push","append","$559c39b934b932c4$var$onPointerMove","e","classList","toggle","target","HTMLDivElement","$559c39b934b932c4$var$onPointerUp","removeEventListener","remove","gameAreaRect","pieceRect","pieceCenterRelativeToGameAreaX","pieceCenterRelativeToGameAreaY","totalTilesX","round","totalTilesY","floor","scene","correct","every","alert","addEventListener","nextPiece","filter","sort","random","pop","zIndex","setPointerCapture","pointerId"],"version":3,"file":"index.d0ccefaa.js.map"}