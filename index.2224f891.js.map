{"mappings":"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","sources":["src/utils/game.ts","src/utils/index.ts","src/index.ts"],"sourcesContent":["/**\n * Ограничивает значение сверху и снизу\n */\nexport const clamp = (n: number, min: number, max: number): number => Math.min(max, Math.max(min, n))\n\n/**\n * Передвигает элемент при этом учитывает границы экрана и возможный offset, заданный на элементе\n */\nexport const move = (element: HTMLElement, x: number, y: number): void => {\n  const offsetX = parseFloat(element.dataset.offsetX ?? '0')\n  const offsetY = parseFloat(element.dataset.offsetY ?? '0')\n\n  element.style.transform = `translate(\n    ${clamp(x - offsetX, 0, window.innerWidth - element.clientWidth) - window.innerWidth / 2 + window.scrollX}px, \n    ${clamp(y - offsetY, 0, window.innerHeight - element.clientHeight) - window.innerHeight / 2 + window.scrollY}px\n  )`\n}\n\n/**\n * Получает кусочек пазла\n */\nexport const getPiece = (\n  src: string,\n  width: number,\n  height: number,\n  tilesCountX: number,\n  tilesCountY: number,\n  tileX: number,\n  tileY: number\n): HTMLDivElement => {\n  const piece = document.createElement('div')\n\n  piece.dataset.piece = 'true'\n  piece.hidden = true\n  piece.style.cssText = `\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: ${width}px;\n    height: ${height}px;\n    background-image: url(${src});\n    background-position: ${-width * tileX}px ${-height * tileY}px;\n    background-size: ${tilesCountX * 100}% ${tilesCountY * 100}%;\n    transform: translate(0, 0);\n    user-select: none;\n  `\n\n  return piece\n}\n\nlet didWin = false\nexport const checkWin = (scene: HTMLElement[]): void => {\n  if (!didWin && scene.every((element) => element.dataset.correct === 'true')) {\n    didWin = true\n    alert('Pobeda')\n  }\n}\n","export * from './game'\n\n/**\n * Возвращает растояние между двумя точками\n */\nexport const getDistance = (x1: number, y1: number, x2: number, y2: number): number => (\n  ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n)\n\n/**\n * Проверяет, попадает ли точка в элемент\n */\nexport const isIntersecting = (element: Element, x: number, y: number): boolean => {\n  const elementRect = element.getBoundingClientRect()\n\n  return x >= elementRect.left && x <= elementRect.right && y >= elementRect.top && y <= elementRect.bottom\n}\n","import { getPiece, getDistance, isIntersecting, move, checkWin } from './utils'\n\nconst PIECE_COUNT_X = 3\nconst PIECE_COUNT_Y = 2\nconst PIECE_WIDTH = 120\nconst PIECE_HEIGHT = 100\nconst IMAGE = `${process.env.RANDOM_IMAGE_SERVICE}/${PIECE_WIDTH * PIECE_COUNT_X}/${PIECE_HEIGHT * PIECE_COUNT_Y}`\n\nconst game = document.querySelector<HTMLDivElement>('.game')\nconst gameArea = document.querySelector<HTMLDivElement>('.game__area')\nconst bag = document.querySelector<HTMLDivElement>('.game__bag')\n\n// Хранит значение z-index последнего передвинутого элемента\nlet zIndex = 1\n\nif (game === null || gameArea === null || bag === null) {\n  throw Error('No game area found')\n}\n\ngameArea.style.width = `${PIECE_WIDTH * PIECE_COUNT_X}px`\ngameArea.style.height = `${PIECE_HEIGHT * PIECE_COUNT_Y}px`\n\nconst scene = new Array<HTMLDivElement>()\n\nfor (let y = 0; y < PIECE_COUNT_Y; y++) {\n  for (let x = 0; x < PIECE_COUNT_X; x++) {\n    const piece = getPiece(IMAGE, PIECE_WIDTH, PIECE_HEIGHT, PIECE_COUNT_X, PIECE_COUNT_Y, x, y)\n\n    scene.push(piece)\n    game.append(piece)\n  }\n}\n\nconst onPointerMove = (e: PointerEvent): void => {\n  bag.classList.toggle('game__bag--active', isIntersecting(bag, e.x, e.y))\n\n  if (!(e.target instanceof HTMLDivElement && 'piece' in e.target.dataset)) {\n    return\n  }\n\n  move(e.target, e.x, e.y)\n}\n\nconst onPointerUp = (e: PointerEvent): void => {\n  game.removeEventListener('pointermove', onPointerMove)\n  game.removeEventListener('pointerup', onPointerUp)\n\n  bag.classList.remove('game__bag--active')\n\n  if (!(e.target instanceof HTMLDivElement && 'piece' in e.target.dataset)) {\n    return\n  }\n\n  const piece = e.target\n  piece.dataset.offsetX = '0'\n  piece.dataset.offsetY = '0'\n\n  if (isIntersecting(bag, e.x, e.y)) {\n    piece.hidden = true\n  }\n\n  const gameAreaRect = gameArea.getBoundingClientRect()\n  const pieceRect = piece.getBoundingClientRect()\n  const pieceCenterRelativeToGameAreaX = pieceRect.left - gameAreaRect.left + pieceRect.width / 2\n  const pieceCenterRelativeToGameAreaY = pieceRect.top - gameAreaRect.top + pieceRect.height / 2\n  const totalTilesX = Math.round(gameAreaRect.width / pieceRect.width)\n  const totalTilesY = Math.round(gameAreaRect.height / pieceRect.height)\n  const tileX = Math.floor(pieceCenterRelativeToGameAreaX / gameAreaRect.width * totalTilesX)\n  const tileY = Math.floor(pieceCenterRelativeToGameAreaY / gameAreaRect.height * totalTilesY)\n\n  if (\n    tileX >= 0 && tileX < totalTilesX && tileY >= 0 && tileY < totalTilesY &&\n    getDistance(\n      tileX * pieceRect.width + pieceRect.width / 2, tileY * pieceRect.height + pieceRect.height / 2,\n      pieceCenterRelativeToGameAreaX, pieceCenterRelativeToGameAreaY\n    ) < 0.15 * getDistance(\n      pieceRect.left, pieceRect.top,\n      pieceRect.right, pieceRect.bottom\n    )\n  ) {\n    piece.dataset.correct = scene[tileY * totalTilesX + tileX] === piece ? 'true' : 'false'\n\n    move(piece, gameAreaRect.left + tileX * pieceRect.width, gameAreaRect.top + tileY * pieceRect.height)\n    checkWin(scene)\n  } else {\n    piece.dataset.correct = 'false'\n  }\n}\n\nconst onPointerDown = (e: PointerEvent): void => {\n  let piece: HTMLDivElement | undefined\n  let offsetX = e.offsetX\n  let offsetY = e.offsetY\n\n  if (e.target instanceof HTMLDivElement && 'piece' in e.target.dataset) {\n    piece = e.target\n  } else if (isIntersecting(bag, e.x, e.y)) {\n    const availablePieces = scene\n      .filter((element) => element.hidden)\n      .sort(() => Math.random() - 0.5)\n    const nextPiece = availablePieces.pop()\n\n    if (typeof nextPiece !== 'undefined') {\n      piece = nextPiece\n      offsetX = nextPiece.clientWidth / 2\n      offsetY = nextPiece.clientHeight / 2\n    }\n  }\n\n  if (typeof piece === 'undefined') {\n    return\n  }\n\n  piece.hidden = false\n  piece.dataset.offsetX = `${offsetX}`\n  piece.dataset.offsetY = `${offsetY}`\n  piece.style.zIndex = `${zIndex++}`\n  piece.setPointerCapture(e.pointerId)\n  move(piece, e.x, e.y)\n\n  game.addEventListener('pointermove', onPointerMove)\n  game.addEventListener('pointerup', onPointerUp)\n}\n\ngame.addEventListener('pointerdown', onPointerDown)\n"],"names":["$59bc3e1a2a4fcdd3$export$7d15b64cf5a3a4c4","n","min","max","Math","$59bc3e1a2a4fcdd3$export$d947e5f4f4c48d48","element","x","y","offsetX","parseFloat","dataset","offsetY","style","transform","window","innerWidth","clientWidth","scrollX","innerHeight","clientHeight","scrollY","$59bc3e1a2a4fcdd3$export$191e7bd1dd3304e7","src","width","height","tilesCountX","tilesCountY","tileX","tileY","piece","document","createElement","hidden","cssText","$59bc3e1a2a4fcdd3$var$didWin","$c9497f80d2c36c0c$export$79376507b09a66f","x1","y1","x2","y2","$c9497f80d2c36c0c$export$8d3dd0be5eb9f11f","elementRect","getBoundingClientRect","left","right","top","bottom","$c6738dfea0cb8440$var$game","querySelector","$c6738dfea0cb8440$var$gameArea","$c6738dfea0cb8440$var$bag","$c6738dfea0cb8440$var$zIndex","Error","$c6738dfea0cb8440$var$scene","Array","push","append","$c6738dfea0cb8440$var$onPointerMove","e","classList","toggle","target","HTMLDivElement","$c6738dfea0cb8440$var$onPointerUp","removeEventListener","remove","gameAreaRect","pieceRect","pieceCenterRelativeToGameAreaX","pieceCenterRelativeToGameAreaY","totalTilesX","round","totalTilesY","floor","scene","correct","every","alert","addEventListener","nextPiece","filter","sort","random","pop","zIndex","setPointerCapture","pointerId"],"version":3,"file":"index.2224f891.js.map"}